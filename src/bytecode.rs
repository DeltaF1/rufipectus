use slice_dst::SliceDst;
use slice_dst::SliceWithHeader;
use std::alloc::Layout;
use std::cell::Ref;
use std::cell::RefCell;
use std::cell::UnsafeCell;
use std::collections::HashMap;
use std::ptr;
use std::rc::Rc;

type CodeAddress = usize;

#[derive(Clone, Copy)]
enum PrimitiveValue {
    Boolean(bool),
    Number(f64),
    String(*const [u8]),
    Range(isize, isize, bool),
    Null,
}

#[derive(Clone)]
enum Value {
    Primitive(PrimitiveValue),
    List(Vec<Value>),
    Map(HashMap<PrimitiveValue, Value>),
    Object(ObjectRef),
}

// Here we go again...
#[derive(Clone)]
struct ObjectRef(DSTRefCell<ObjectRef, Value, Rc<DSTRefCellInner<ObjectRef, Value>>>);

type DSTRefCellInner<Header, SliceType> = 
    SliceWithHeader<(Header, RefCell<()>), std::cell::UnsafeCell<SliceType>>;

struct DSTRefCell<Header, SliceType, Pointer: slice_dst::AllocSliceDst<DSTRefCellInner<Header, SliceType>>>
(
    Pointer//::<DSTRefCellInner<Header, SliceType>>
    ,std::marker::PhantomData<(Header, SliceType)>
);

impl<H, S, A> DSTRefCell<H, S, A>
        where A: slice_dst::AllocSliceDst<DSTRefCellInner<H, S>>,
              A: std::ops::Deref<Target = DSTRefCellInner<H, S>>
{
    fn new<I>(sized: H, slice: I) -> A
        where 
              I: IntoIterator<Item=S>,
              I::IntoIter: ExactSizeIterator,
        {
        SliceWithHeader::new::<A, _>((sized, RefCell::new(())), slice.into_iter().map(|s: S| UnsafeCell::new(s))).into()
    }

    fn borrow_header(&self) -> std::cell::Ref<H> {
        Ref::map(self.0.header.1.borrow(), |_| {
            // Safety: Can coerce this lifetime since `header.0` will never be accessed unless the
            // original RefCell is succesfully borrowed first
            unsafe { &*(&self.0.header.0 as *const H) }
        })
    }

    fn borrow_slice(&self) -> std::cell::Ref<[S]> {
        Ref::map(self.0.header.1.borrow(), |_| {
            // SAFETY: self.slice will not be accessed unless by one of these methods that borrows
            // the refcell first
            // SAFETY: Idk if *[UnsafeCell<T>] -> *[T] is allowed or not
            unsafe { &*(&self.0.slice as *const [UnsafeCell<S>] as *const [S]) }
        })
    }

    fn borrow_header_mut(&self) -> std::cell::RefMut<H> {
        todo!()
    }

    fn borrow_slice_mut(&self) -> std::cell::RefMut<[S]> {
        todo!()
    }
}

/*
let Class = ClassObject

MetaClassObject = Object {
    class = Class,
    values = [
        supertype: *ClassObject,
        name: String,
        methods: List<List<String, CodeAddress>>,
    ]
}

ClassObject = Object {
    class = metaclass of this class,
    values = [
        num_fields: Number,
        name: String,
        methods: List<List<String, CodeAddress>>,
    ]
}
*/
struct ClassObject {
    supertype: Option<&'static ClassObject>,
    num_fields: usize,
    Name: String,
    methods: Vec<(String, CodeAddress)>,
}

struct ExactRepeat<T> {
    value: T,
    n: usize,
}

impl<T> ExactRepeat<T> {
    fn new(value: T, n: usize) -> Self {
        ExactRepeat { value, n }
    }
}

impl<T: Clone> Iterator for ExactRepeat<T> {
    type Item = T;

    fn next(&mut self) -> Option<Self::Item> {
        if self.n == 0 {
            return None;
        }

        self.n -= 1;
        self.value.clone().into()
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        (self.n, self.n.into())
    }
}

impl<T: Clone> ExactSizeIterator for ExactRepeat<T> {}

impl ClassObject {
    unsafe fn cast_from_object(obj: &ObjectRef) -> Self {
        todo!()
    }
}

impl ObjectRef {
    /// #Safety
    ///
    /// Class must be an instance of a class constructed
    /// This method should only be called by constructor code which is auto-generated by our
    /// compiler
    unsafe fn from_class(class: &ObjectRef) -> ObjectRef {
        let num_fields = { ClassObject::cast_from_object(&class).num_fields };
        todo!()
        /*
        Object (
            SliceWithHeader::new(
                class.clone(),
                ExactRepeat::new(Value::Primitive(PrimitiveValue::Null), num_fields)
            )
        ).into()
        */
    }

    fn find_method(&self, name: &str) -> Option<CodeAddress> {
        todo!()
    }
}

struct FunctionObject {
    arity: usize,
    code: CodeAddress,
}

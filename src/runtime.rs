use slice_dst::SliceWithHeader;
use std::cell::Ref;
use std::cell::RefCell;
use std::cell::UnsafeCell;
use std::collections::HashMap;
use std::rc::Rc;

mod stack;

type CodeAddress = usize;

#[derive(Clone, Copy)]
enum PrimitiveValue {
    Boolean(bool),
    Number(f64),
    String(*const [u8]),
    Range(isize, isize, bool),
    Null,
}

#[derive(Clone)]
enum Value {
    Primitive(PrimitiveValue),
    List(Vec<Value>),
    Map(HashMap<PrimitiveValue, Value>),
    Object(ObjectRef),
}

// Here we go again...
#[derive(Clone)]
struct ObjectRef(Rc<DSTRefCellInner<ObjectRef, Value>>);

type DSTRefCellInner<Header, SliceType> =
    SliceWithHeader<(Header, RefCell<()>), std::cell::UnsafeCell<SliceType>>;

impl ObjectRef {
    fn new<I>(class: ObjectRef, slice: I) -> ObjectRef
    where
        I: IntoIterator<Item = Value>,
        I::IntoIter: ExactSizeIterator,
    {
        ObjectRef(
            (SliceWithHeader::new::<Rc<DSTRefCellInner<ObjectRef, Value>>, _>(
                (class, RefCell::new(())),
                slice.into_iter().map(|s: Value| UnsafeCell::new(s)),
            ))
            .into(),
        )
    }

    // TODO: Return Ref<(ObjectRef, [Value])> instead
    fn borrow_class(&self) -> std::cell::Ref<ObjectRef> {
        Ref::map(self.0.header.1.borrow(), |_| {
            // Safety: Can coerce this lifetime since `header.0` will never be accessed unless the
            // original RefCell is succesfully borrowed first
            unsafe { &*(&self.0.header.0 as *const ObjectRef) }
        })
    }

    fn borrow_fields(&self) -> std::cell::Ref<[Value]> {
        Ref::map(self.0.header.1.borrow(), |_| {
            // SAFETY: self.slice will not be accessed unless by one of these methods that borrows
            // the refcell first
            // SAFETY: Idk if *[UnsafeCell<T>] -> *[T] is allowed or not
            unsafe { &*(&self.0.slice as *const [UnsafeCell<Value>] as *const [Value]) }
        })
    }

    fn borrow_class_mut(&self) -> std::cell::RefMut<ObjectRef> {
        todo!()
    }

    fn borrow_fields_mut(&self) -> std::cell::RefMut<[Value]> {
        todo!()
    }
}

/*
let Class = ClassObject

type MetaClassObject = Object {
    class = Class,
    values = [
        supertype: *ClassObject,
        name: String,
        methods: List<List<String, CodeAddress>>,
    ]
}

type ClassObject = Object {
    class = metaclass of this class,
    values = [
        num_fields: Number,
        name: String,
        methods: List<List<String, CodeAddress>>,
    ]
}
*/
struct ClassObject {
    supertype: Option<&'static ClassObject>,
    num_fields: usize,
    name: String,
    methods: Vec<(String, CodeAddress)>,
}

impl ClassObject {
    unsafe fn cast_from_object(obj: &ObjectRef) -> Self {
        todo!()
    }
}

impl ObjectRef {
    /// #Safety
    ///
    /// Class must be an instance of a class constructed
    /// This method should only be called by constructor code which is auto-generated by our
    /// compiler
    unsafe fn from_class(class: &ObjectRef) -> ObjectRef {
        let num_fields = { ClassObject::cast_from_object(&class).num_fields };
        todo!()
        /*
        Object (
            SliceWithHeader::new(
                class.clone(),
                ExactRepeat::new(Value::Primitive(PrimitiveValue::Null), num_fields)
            )
        ).into()
        */
    }

    fn find_method(&self, name: &str) -> Option<CodeAddress> {
        todo!()
    }
}

struct FunctionObject {
    arity: usize,
    code: CodeAddress,
}
